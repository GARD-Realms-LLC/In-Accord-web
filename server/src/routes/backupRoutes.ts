import { Router, Request, Response } from 'express';
import fs from 'fs';
import path from 'path';
import https from 'https';

const router = Router();
// __dirname when this file runs is server/src/routes
// So: __dirname/../../.. = server/src/routes/../../.. = root/
const repoRoot = path.resolve(__dirname, '..', '..', '..');
const backupDir = path.join(repoRoot, 'backups');

console.log('[backup] init: repoRoot =', repoRoot);
console.log('[backup] init: backupDir =', backupDir);

function ensureBackupDir(dir: string) {
  try {
    if (!fs.existsSync(dir)) {
      console.log('[backup] creating backupDir:', dir);
      fs.mkdirSync(dir, { recursive: true });
      console.log('[backup] backupDir created successfully');
    }
  } catch (err) {
    console.error('[backup] failed to create backupDir:', dir, err);
    throw err;
  }
}

function safeReadJson(filePath: string) {
  try {
    if (!fs.existsSync(filePath)) return null;
    const raw = fs.readFileSync(filePath, 'utf8');
    return JSON.parse(raw);
  } catch (err) {
    console.warn('[backup] failed to read sample file', filePath, err);
    return null;
  }
}

router.post('/', async (req: Request, res: Response) => {
  const { location, localPath, r2Config } = req.body as {
    location?: 'local' | 'cloud' | 'both';
    localPath?: string;
    r2Config?: {
      accountId?: string;
      apiToken?: string;
      bucket?: string;
      prefix?: string;
    };
  };
  const loc = location || 'local';
  if (!['local', 'cloud', 'both'].includes(loc)) {
    return res.status(400).json({ ok: false, error: 'invalid location' });
  }

  try {
    console.log('[backup] start request', { loc });
    console.log('[backup] repoRoot resolved to:', repoRoot);
    console.log('[backup] backupDir resolved to:', backupDir);
    const targetDir = (localPath && localPath.trim()) ? localPath.trim() : backupDir;
    ensureBackupDir(targetDir);

    const timestamp = new Date();
    const stamp = timestamp.toISOString().replace(/[^0-9]/g, '').slice(0, 14); // YYYYMMDDhhmmss
    const fileName = `backup-${stamp}-${loc}.json`;
    const filePath = path.join(targetDir, fileName);

    console.log('[backup] writing to:', filePath);

    const users = safeReadJson(path.join(repoRoot, 'server', 'data', 'users.json'));
    const sessions = safeReadJson(path.join(repoRoot, 'server', 'data', 'sessions.json'));

    const payload = {
      createdAt: timestamp.toISOString(),
      location: loc,
      note: 'Local demo backup generated by admin Run Now.',
      includes: {
        users: Array.isArray(users) ? users.length : (users?.users?.length ?? 0),
        sessions: Array.isArray(sessions) ? sessions.length : 0,
      },
      data: {
        users,
        sessions,
      },
    };

    const json = JSON.stringify(payload, null, 2);
    console.log('[backup] about to write', Buffer.byteLength(json, 'utf8'), 'bytes to:', filePath);
    fs.writeFileSync(filePath, json, 'utf8');
    console.log('[backup] writeFileSync completed');

    // Verify the file was actually written before claiming success
    const exists = fs.existsSync(filePath);
    const stat = exists ? fs.statSync(filePath) : null;
    console.log('[backup] file existence check:', { exists, filePath, statSize: stat?.size });
    
    if (!exists) {
      throw new Error(`File was not written or not found after write: ${filePath}`);
    }

    const sizeBytes = Buffer.byteLength(json, 'utf8');
    console.log('[backup] saved', { filePath, sizeBytes, statSize: stat?.size, fileExists: exists });

    let detail = `Saved backup locally: ${filePath} (${(sizeBytes / (1024 * 1024)).toFixed(2)} MB)`;
    let r2Uploaded = false;

    if (loc === 'cloud' || loc === 'both') {
      const rawAccountId = r2Config?.accountId?.trim() || '';
      const rawBucket = r2Config?.bucket?.trim() || '';
      const apiToken = r2Config?.apiToken?.trim();
      const userPrefix = r2Config?.prefix?.trim();

      // Extract bare account ID if user pasted a URL (e.g., dash.cloudflare.com/.../accounts/<id>/...)
      const accountMatch = rawAccountId.match(/[a-f0-9]{32}/i);
      const accountId = accountMatch ? accountMatch[0] : rawAccountId;

      // If bucket contains slashes, treat the first segment as bucket name and the rest as implied prefix
      const bucketSegments = rawBucket.split(/[\\/]+/).filter(Boolean);
      const bucket = bucketSegments[0];
      const bucketPrefix = bucketSegments.slice(1).join('/') || '';

      // Combine implicit prefix from bucket path with explicit prefix field
      const combinedPrefix = [bucketPrefix, userPrefix].filter(Boolean).join('/');
      const normalizedPrefix = combinedPrefix.replace(/^\/+|\/+$/g, '');

      if (!accountId || !apiToken || !bucket) {
        throw new Error('Cloud backup requested but R2 configuration is incomplete (need accountId, apiToken, bucket)');
      }

      const objectKey = normalizedPrefix ? `${normalizedPrefix}/${fileName}` : fileName;
      const encodedKey = objectKey.split('/').map(part => encodeURIComponent(part)).join('/');

      const options: https.RequestOptions = {
        method: 'PUT',
        hostname: 'api.cloudflare.com',
        path: `/client/v4/accounts/${encodeURIComponent(accountId)}/r2/buckets/${encodeURIComponent(bucket)}/objects/${encodedKey}`,
        headers: {
          'Authorization': `Bearer ${apiToken}`,
          'Content-Type': 'application/json',
          'Content-Length': Buffer.byteLength(json, 'utf8'),
        },
      };

      console.log('[backup] uploading to R2', { bucket, objectKey, path: options.path });

      await new Promise<void>((resolve, reject) => {
        const uploadReq = https.request(options, (uploadRes) => {
          let body = '';
          uploadRes.on('data', (chunk) => { body += chunk; });
          uploadRes.on('end', () => {
            if (uploadRes.statusCode && uploadRes.statusCode >= 200 && uploadRes.statusCode < 300) {
              console.log('[backup] R2 upload success', { statusCode: uploadRes.statusCode });
              return resolve();
            }
            const errMsg = `[backup] R2 upload failed (${uploadRes.statusCode}): ${body || uploadRes.statusMessage}`;
            console.error(errMsg);
            return reject(new Error(errMsg));
          });
        });

        uploadReq.on('error', (uploadErr) => {
          console.error('[backup] R2 upload network error', uploadErr);
          reject(uploadErr);
        });

        uploadReq.write(json);
        uploadReq.end();
      });

      r2Uploaded = true;
      detail = `${detail} + uploaded to R2: ${bucket}/${objectKey}`;
    }

    return res.json({
      ok: true,
      fileName,
      filePath,
      sizeBytes,
      r2Uploaded,
      detail,
    });
  } catch (err) {
    console.error('[backup] failed to write backup', err);
    return res.status(500).json({ ok: false, error: 'Failed to write backup file', detail: String((err as Error)?.message || err) });
  }
});

export default router;
